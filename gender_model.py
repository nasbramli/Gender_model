# -*- coding: utf-8 -*-
"""Gender_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZrHtfywNkHYII87SEVNowVH5WLeq4hwL

# Gender Classification

Dataset Used is -
https://talhassner.github.io/home/projects/Adience/Adience-data.html#frontalized
"""

import os

path_faces = './aligned'

image_folder_dict = {}
for folder in os.listdir(path_faces):
    image_files = []
    if folder[-4:] != '.txt':
        for files in os.listdir(path_faces + '/' + folder):
            if files[-4:] == '.jpg':
                  image_files.append(files)
        image_folder_dict[f'{folder}'] = image_files

import pandas as pd

def load_fold_data():
    fold_0_path = './aligned/fold_0_data.txt'
    fold_1_path = './aligned/fold_1_data.txt'
    fold_2_path = './aligned/fold_2_data.txt'
    fold_3_path = './aligned/fold_3_data.txt'
    fold_4_path = './aligned/fold_4_data.txt'

    fold_0_df = pd.read_csv(fold_0_path, sep='\t')
    fold_1_df = pd.read_csv(fold_1_path, sep='\t')
    fold_2_df = pd.read_csv(fold_2_path, sep='\t')
    fold_3_df = pd.read_csv(fold_3_path, sep='\t')
    fold_4_df = pd.read_csv(fold_4_path, sep='\t')

    full_fold_df = fold_0_df.append(fold_1_df)
    full_fold_df = full_fold_df.append(fold_2_df)
    full_fold_df = full_fold_df.append(fold_3_df)
    full_fold_df = full_fold_df.append(fold_4_df)

    return full_fold_df

full_fold_df = load_fold_data()

full_fold_df.head()

full_fold_df.info()

full_fold_df = full_fold_df.reset_index(drop=True)
print(full_fold_df.gender.unique())

# There are certain ages which lies in between the bins,
# so we are removing them to avoid confusion
print(full_fold_df.age.unique())

# as you can see there are two bins which is not in
# offical bins so we have to remove than also
# Offical bins = (0-2, 4-6, 8-13, 15-20, 25-32, 38-43, 48-53, 60-)
# unwanted bins = (8-23) (38, 48) as we cannot include inside any other bins
# (27-32) (38, 42) bins can be included in the (25-32), (38-43) class

def remove_unwanted_data(full_fold_df):
    # removing nan and 'u' values from the gender
    index_df = full_fold_df[full_fold_df.gender.isna()].index
    full_fold_df.drop(index_df, inplace=True)
    index_df = full_fold_df[full_fold_df.gender == 'u'].index
    full_fold_df.drop(index_df, inplace=True)

    full_fold_df = full_fold_df[full_fold_df['age'].str.contains('\)')]

    full_fold_df = full_fold_df[~full_fold_df['age'].str.contains('(8, 23)')]

    full_fold_df = full_fold_df[~full_fold_df['age'].str.contains('(38, 48)')]

    full_fold_df = full_fold_df.drop_duplicates(subset=['user_id', 'original_image'])

    return full_fold_df

full_fold_df = remove_unwanted_data(full_fold_df)
final_df = full_fold_df[['user_id', 'original_image', 'face_id', 'age', 'gender']]

class_dict = {
    'm':0,
    'f':1
}

classes = []
for i in final_df.index:
    gender = final_df.loc[i, 'gender']
    classes.append(class_dict[gender])

len(classes)

final_df['class'] = classes

final_df = final_df.reset_index(drop=True)

img_path = []
base_path = './aligned/'
for idx in final_df.index:
  file_name = final_df.loc[idx,'original_image']
  folder_names = image_folder_dict[final_df.loc[idx,'user_id']]
  face_id = str(final_df.loc[idx,'face_id'])
  for i in folder_names:
    path = base_path + final_df.loc[idx,'user_id'] + '/' + i
    if path.endswith(face_id+'.'+file_name):
      img_path.append(path)

final_df['path'] = img_path

import tensorflow as tf

sess = tf.compat.v1.Session()

import numpy as np
import cv2
import random
from sklearn.decomposition import PCA

# Seperating the X and Y
y = final_df['class'].values
X = np.empty((10870, 199, 199, 3), dtype=np.uint8)
for idx,i in enumerate(final_df.path):
    img = cv2.imread(i, cv2.IMREAD_COLOR)
    img = cv2.resize(img,(199, 199))
    img = img.reshape(199, 199, 3)
    X[idx,:] = img

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# for memory management run after train_test_split to
# save memory
del X
del y

from tensorflow.keras.utils import to_categorical

y_train = to_categorical(y_train)
y_test = to_categorical(y_test)

input_shape = X_train.shape[1:]

def build_model_cnn(input_shape):
    model = tf.keras.models.Sequential()
    model.add(tf.keras.layers.Conv2D(filters=16, kernel_size=3,
                                   strides=1,padding='same',activation='relu',
                                   input_shape = input_shape)),

    model.add(tf.keras.layers.MaxPool2D(pool_size=2, strides=2)),

    model.add(tf.keras.layers.Conv2D(filters=32, kernel_size=3,
                                   strides=1,padding='same',activation='relu')),

    model.add(tf.keras.layers.MaxPool2D(pool_size=2, strides=2)),

    model.add(tf.keras.layers.Conv2D(filters=64, kernel_size=3,
                                   strides=1,padding='same',activation='relu')),

    #model.add(tf.keras.layers.BatchNormalization(axis=-1)),

    model.add(tf.keras.layers.MaxPool2D(pool_size=2, strides=2)),

    model.add(tf.keras.layers.Conv2D(filters=128, kernel_size=3,
                                   strides=1,padding='same',activation='relu')),

    model.add(tf.keras.layers.Conv2D(filters=256, kernel_size=3,
                                   strides=1,padding='same',activation='relu')),
    model.add(tf.keras.layers.MaxPool2D(pool_size=2, strides=2)),

    model.add(tf.keras.layers.Flatten()),
    model.add(tf.keras.layers.Dropout(0.8))
    model.add(tf.keras.layers.Dense(units=2, activation='softmax'))

    opt = tf.keras.optimizers.Adam()
    model.compile(optimizer=opt,
                loss='CategoricalCrossentropy',
                metrics=['accuracy'])

    model.summary()

    return model

gender_model = build_model_cnn(input_shape)

tf.debugging.set_log_device_placement(True)
stop_early = tf.keras.callbacks.EarlyStopping(
                            monitor='val_loss', patience=5)
checkpoint = tf.keras.callbacks.ModelCheckpoint(
                        'gender_model.h5',
                        verbose=1,
                        save_best_only=True,
                        monitor='val_loss')

history = gender_model.fit(x=X_train,y= y_train,
              validation_data=(X_test, y_test),
              epochs=50,
              callbacks=[stop_early, checkpoint])

import matplotlib.pyplot as plt

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

loss = history.history['loss']
val_loss = history.history['val_loss']

epochs_range = range(len(history.history['loss']))

plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(epochs_range, acc, label='Training Accuracy')
plt.plot(epochs_range, val_acc, label='Validation Accuracy')
plt.legend(loc='lower right')
plt.title('Training and Validation Accuracy')

plt.subplot(1, 2, 2)
plt.plot(epochs_range, loss, label='Training Loss')
plt.plot(epochs_range, val_loss, label='Validation Loss')
plt.legend(loc='upper right')
plt.title('Training and Validation Loss')
plt.show()

print(f'the Accuracy of the model is {max(val_acc)}')

# for Memory Managment
del gender_model

tf.compat.v1.reset_default_graph()

